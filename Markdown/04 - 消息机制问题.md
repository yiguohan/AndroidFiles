[TOC]

### 1. 谈谈消息机制Hander作用？有哪些要素？流程是怎样的？

#### 1.1 谈谈消息机制Hander作用？

跨线程通信。当子线程中进行耗时操作后需要更新UI时，通过Handler将有关UI的操作切换到主线程中执行。

#### 1.2 有哪些要素？

1. Message（消息）：需要被传递的消息，其中包含了消息ID，消息处理对象以及处理的数据等，由MessageQueue统一列队，最终由Handler处理。
2. MessageQueue（消息队列）：用来存放Handler发送过来的消息，内部通过单链表的数据结构来维护消息列表，等待Looper的抽取。
3. Handler（处理者）：负责Message的发送及处理。通过 Handler.sendMessage() 向消息池发送各种消息事件；通过 Handler.handleMessage() 处理相应的消息事件。
4. Looper（消息泵）：通过Looper.loop()不断地从MessageQueue中抽取Message，按分发机制将消息分发给目标处理者。

#### 1.3 流程是怎样的？

1. Handler.sendMessage()发送消息时，会通过MessageQueue.enqueueMessage()向MessageQueue中添加一条消息；
2. 通过Looper.loop()开启循环后，不断轮询调用MessageQueue.next()；
3. 调用目标Handler.dispatchMessage()去传递消息，目标Handler收到消息后调用Handler.handlerMessage()处理消息。

![image](https://upload-images.jianshu.io/upload_images/4432347-ec2cab2911cd2c3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### *2. 为什么一个线程只有一个Looper、只有一个MessageQueue，可以有多个Handler？

> 注意：一个Thread只能有一个Looper，可以有多个Handler

Looper有一个MessageQueue，可以处理来自多个Handler的Message；

MessageQueue有一组待处理的Message，这些Message可来自不同的Handler；

Message中记录了负责发送和处理消息的Handler；

Handler中有Looper和MessageQueue。

需使用Looper的prepare方法，Looper.prepare()。可以看下源代码，Android中一个线程最多仅仅能有一个Looper，若在已有Looper的线程中调用Looper.prepare()会抛出RuntimeException(“Only one Looper may be created per thread”)。

### 3. 可以在子线程直接new一个Handler吗？会出现什么问题，那该怎么做？

不同于主线程直接new一个Handler，由于子线程的Looper需要手动去创建，在创建Handler时需要多一些方法：

Handler的工作是依赖于Looper的，而Looper（与消息队列）又是属于某一个线程（ThreadLocal是线程内部的数据存储类，通过它可以在指定线程中存储数据，其他线程则无法获取到），其他线程不能访问。因此Handler就是间接跟线程是绑定在一起了。因此要使用Handler必须要保证Handler所创建的线程中有Looper对象并且启动循环。因为子线程中默认是没有Looper的，所以会报错。

```java
handler = null;
new Thread(new Runnable() {
   private Looper mLooper;
   @Override
   public void run() {
       //必须调用Looper的prepare方法为当前线程创建一个Looper对象，然后启动循环
       //prepare方法中实质是给ThreadLocal对象创建了一个Looper对象
       //如果当前线程已经创建过Looper对象了，那么会报错
       Looper.prepare();
       handler = new Handler();
       //获取Looper对象
       mLooper = Looper.myLooper();
       //启动消息循环
       Looper.loop();
       //在适当的时候退出Looper的消息循环，防止内存泄漏
       mLooper.quit();
   }
}).start();
```

主线程中默认是创建了Looper并且启动了消息的循环的，因此不会报错：应用程序的入口是ActivityThread的main方法，在这个方法里面会创建Looper，并且执行Looper的loop方法来启动消息的循环，使得应用程序一直运行。

### 4. Looper.prepare()能否调用两次或者多次，会出现什么情况？

#### 4.1 Looper.prepare()方法源码分析

可以看到Looper中有一个ThreadLocal成员变量，熟悉JDK的同学应该知道，当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。

``` java
public static void prepare() {
    prepare(true);
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException("Only one Looper may be created per thread");
    }
    sThreadLocal.set(new Looper(quitAllowed));
}
```

#### 4.2 思考：Looper.prepare()能否调用两次或者多次

如果运行，则会报错，并提示prepare中的Excetion信息。由此可以得出在每个线程中Looper.prepare()能且只能调用一次

```java
//这里Looper.prepare()方法调用了两次
Looper.prepare();
Looper.prepare();
Handler mHandler = new Handler() {
   @Override
   public void handleMessage(Message msg) {
       if (msg.what == 1) {
          Log.i(TAG, "在子线程中定义Handler，并接收到消息。。。");
       }
   }
};
Looper.loop();
```

### 5. 为什么系统不建议在子线程访问UI，不对UI控件的访问加上锁机制的原因？

#### 5.1 为什么系统不建议在子线程访问UI

系统不建议在子线程访问UI的原因是，UI控件非线程安全，在多线程中并发访问可能会导致UI控件处于不可预期的状态。

#### 5.2 不对UI控件的访问加上锁机制的原因

- 上锁会让UI控件变得复杂和低效
- 上锁后会阻塞某些进程的执行

### 6. Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？

#### 6.1 Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？

因为Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。

#### 6.2 loop的循环消耗性能吗？

主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。

简单的来说：ActivityThread的main方法主要就是做消息循环，一旦退出消息循环，那么你的程序也就可以退出了。



### 7. Message可以如何创建？哪种效果更好，为什么？runOnUiThread如何实现子线程更新UI？

#### 7.1 创建Message对象的几种方式：

1. Message msg = new Message();
2. Message msg = Message.obtain();
3. Message msg = handler1.obtainMessage();

> 后两种方法都是从整个Messge池中返回一个新的Message实例，能有效避免重复Message创建对象，因此更鼓励这种方式创建Message

#### 7.2 runOnUiThread如何实现子线程更新UI

如果msg.callback为空的话，会直接调用我们的mCallback.handleMessage(msg)，即handler的handlerMessage方法。由于Handler对象是在主线程中创建的，所以handler的handlerMessage方法的执行也会在主线程中。

在runOnUiThread程序首先会判断当前线程是否是UI线程，如果是就直接运行，如果不是则post，这时其实质还是使用的Handler机制来处理线程与UI通讯。

```java
public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}

@Override
public final void runOnUiThread(Runnable action) {
    if (Thread.currentThread() != mUiThread) {
        mHandler.post(action);
    } else {
        action.run();
    }
}
```

### 8. 使用Hanlder的postDealy()后消息队列会发生什么变化？

post delay的Message并不是先等待一定时间再放入到MessageQueue中，而是直接进入并阻塞当前线程，然后将其delay的时间和队头的进行比较，按照触发时间进行排序，如果触发时间更近则放入队头，保证队头的时间最小、队尾的时间最大。此时，如果队头的Message正是被delay的，则将当前线程堵塞一段时间，直到等待足够时间再唤醒执行该Message，否则唤醒后直接执行。

### 9. ThreadLocal有什么作用？如何避免UI线程尽量只做跟UI相关的工作?

#### 9.1 ThreadLocal有什么作用？

ThreadLocal类可实现线程本地存储的功能，把共享数据的可见范围限制在同一个线程之内，无须同步就能保证线程之间不出现数据争用的问题，这里可理解为ThreadLocal帮助Handler找到本线程的Looper。 

#### 9.2 怎么存储呢？底层数据结构是啥？

每个线程的Thread对象中都有一个ThreadLocalMap对象，它存储了一组以ThreadLocal.threadLocalHashCode为key、以本地线程变量为value的键值对，而ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，也就包含了一个独一无二的threadLocalHashCode值，通过这个值就可以在线程键值值对中找回对应的本地线程变量。

#### 9.3 如何避免UI线程尽量只做跟UI相关的工作?

耗时的操作(比如数据库操作，I/O,连接网络或者别的有可能阻塞UI线程的操作)把它放在单独的线程处理尽量用Handler来处理UIthread和别的thread之间的交互.使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。













